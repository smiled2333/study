# 1.Linux

## 1.网络

```route
route :设置路由
	Route命令是用于操作基于内核ip路由表，它的主要作用是创建一个静态路由让指定一个主机或者一个网络通过一个网络接口，如eth0。当使用"add"或者"del"参数时，路由表被修改，如果没有参数，则显示路由表当前的内容。
1.格式: 
route [-f] [-p] [Command [Destination] [mask Netmask] [Gateway] [metric Metric]] [if Interface]] 
2.参数
-c 显示更多信息
-n 不解析名字
-v 显示详细的处理信息
-F 显示发送信息
-C 显示路由缓存
-f 清除所有网关入口的路由表。 
-p 与 add 命令一起使用时使路由具有永久性。
add:添加一条新路由。
del:删除一条路由。
-net:目标地址是一个网络。
-host:目标地址是一个主机。
netmask:当添加一个网络路由时，需要使用网络掩码。
gw:路由数据包通过网关。注意，你指定的网关必须能够达到。
metric：设置路由跳数。
Command 指定您想运行的命令 (Add/Change/Delete/Print)。 
Destination 指定该路由的网络目标。 
mask Netmask 指定与网络目标相关的网络掩码（也被称作子网掩码）。 
Gateway 指定网络目标定义的地址集和子网掩码可以到达的前进或下一跃点 IP 地址。 
metric Metric 为路由指定一个整数成本值标（从 1 至 9999），当在路由表(与转发的数据包目标地址最匹配)的多个路由中进行选择时可以使用。 
if Interface 为可以访问目标的接口指定接口索引。若要获得一个接口列表和它们相应的接口索引，使用 route print 命令的显示功能。可以使用十进制或十六进制值进行接口索引。
3.使用实例
route -n  :查询所有路由信息
route add -net 224.0.0.0 netmask 240.0.0.0 dev eth0 :添加一个网关
route del -net 224.0.0.0 netmask 240.0.0.0 :删除一个路由记录
route add -net 192.168.0.1 netmask 255.255.255.0 gw192.168.1.1 :将0网段的请求路由到1网段上
```

```
ifconfig :查询ip信息
netstat  :查询网络状态
	-t：列出TCP协议端口
　　-u：列出UDP协议端口
　　-n：不使用域名与服务名，而使用IP地址和端口号
　　-l ：仅列出在监听状态网络服务（只有TCP有监听状态）
　　-a：列出所有网络连接
　　-r ：列出路由列表，功能和route命令一致
测试
    ping      :命令 
    telnet    :命令 telnet  [域名或者IP]  [端口]
    trceroute :命令 traceroute  [选项]  IP或域名
		-n：使用IP，不使用域名，速度更快。
wget 	:下载
	 wget http://soft.vpser.net/lnmp1.1-full.tar.gz
```
## 2.文件

```find
find / -name test.txt :查询根目录下 文件与文件夹名字为 test.txt
cat :打开文件
vim :编辑文件
tail:浏览文件 
	-f 动态更新文件
	-n 指定浏览文件后多少行文件
rm :删除
cp :复制
cp /test1/file1 /test3/file2:将file1 文件移动到test3下 并改名为file2
mv :移动
mv /test1/file1 /test3/file2:..
tar :文件压缩解压
    -c: 建立压缩档案
    -x：解压
    -t：查看内容
    -r：向压缩归档文件末尾追加文件
    -u：更新原压缩包中的文件
    以上一次只能使用一个
    -z：有gzip属性的
    -j：有bz2属性的
    -Z：有compress属性的
    -v：显示所有过程
    -O：将文件解开到标准输出
    -f: 是必须的
压缩
 	tar -cvf jpg.tar *.jpg //将目录里所有jpg文件打包成jpg.tar 
解压
	tar -xvf file.tar //解压 tar包
mkdir :
　　-p　　如果目录已经存在，则不会有错误提示。若父目录不存在，将会创建父目录。该选项常用于创建级联目录。
　　-v　　为每个目录显示提示信息。
mkdir 777 test 创建文件夹并赋予最高权限
mkdir test 创建文件夹
```

## 3.shell

格式 

```
#!/bin/sh       # 必须在文件的第一行 表示文件是可以执行的
```

变量定义

```
#定义
a="hello world"  #所有的变量都由字符串组成，并且您不需要对变量进行声明。要赋值给一个变量
#使用
$a   #在如何地方都可以取出变量 但是在字符串中药加上{} 
#如 
qweqwe{$a}qweewq  #这样才可以取出变量 但是当以空格分开时 不用{}

特殊变量

$1:	您可能注意到我们在这里使用了一个特殊的变量$1。该变量包含了传递给该程序的第一个参数值。也就是说，当我们运行：

$*:该变量包含了所有输入的命令行参数值
$#:表示包含参数的个数
```

关键字

```
echo 变量/字符串  #打印
export  #处理过的变量叫做环境变量,通常情况下仅仅在登录脚本中使用环境变量
read 变量名 :

```

流程控制 

```
"if" 表达式 如果条件为真则执行then后面的部分
    if 条件; then
      执行代码
    elif 条件; then
      执行代码
    else
      执行代码
    fi #结尾
    
    [ -f "somefile" ] ：判断是否是一个文件
    [ -x "/bin/ls" ] ：判断/bin/ls是否存在并有可执行权限
    [ -n "$var" ] ：判断$var变量是否有值
    [ "$a" = "$b" ] ：判断$a和$b是否相等

case表达式可以用来匹配一个给定的字符串
    case ... in
    ...) do something here ;;
    esac

例:
    ftype=`file "$1"`
    case "$ftype" in
    "$1: Zip archive"*)
      unzip "$1" ;;
    "$1: gzip compressed"*)
      gunzip "$1" ;;
    "$1: bzip2 compressed"*)
      bunzip2 "$1" ;;
    *) error "File $1 can not be uncompressed with smartzip";;
    esac

      您可能注意到我们在这里使用了一个特殊的变量$1。该变量包含了传递给该程序的第一个参数值。也就是说，当我们运行：
    smartzip articles.zip 
    $1 就是字符串 articles.zip 


select 表达式是一种bash的扩展应用，尤其擅长于交互式使用。用户可以从一组不同的值中进行选择
    select var in ... ; do
     break
    done
    .... now $var can be used ....
例
	#!/bin/sh
    echo "What is your favourite OS?"
    select var in "Linux" "Gnu Hurd" "Free BSD" "Other"; do
        break
    done
    echo "You have selected $var"
    
    同样功能
    while ...; do
    ....
    done
    
    for var in ....; do
     ....
    done
```

运算符

```
&&  || 断路
*    统配符

"" 双引号可以防止通配符扩展但允许变量扩展
'' 它可以防止任何变量扩展
```

函数

```
functionname()
{
# inside the body $1 is the first argument given to the function
# $2 the second ...
body
}
```

命令 

```
Unix 命令 linux系统当值的命令 #这些命令通常是用来进行文件和文字操作的。

echo "some text": 将文字内容打印在屏幕上

wc –l filewc -w filewc -c file: 计算文件行数计算文件中的单词数计算文件中的字符数

grep 'pattern' file: 在文件内搜索字符串比如：grep 'searchstring' file.txt

cut -b colnum file: 指定欲显示的文件内容范围，并将它们输出到标准输出设备比如：输出每行第5个到第9个字符cut -b5-9 file.txt千万不要和cat命令混淆，这是两个完全不同的命令

file somefile: 得到文件类型

read var: 提示用户输入，并将输入赋值给变量

sort file.txt: 对file.txt文件中的行进行排序

uniq: 删除文本文件中出现的行列比如： sort file.txt | uniq

expr: 进行数学运算Example: add 2 and 3expr 2 "+" 3

find: 搜索文件比如：根据文件名搜索find . -name filename -print

tee: 将数据输出到标准输出设备(屏幕) 和文件比如：somecommand | tee outfile
　
basename file: 返回不包含路径的文件名比如： basename /bin/tux将返回 tux

dirname file: 返回文件所在路径比如：dirname /bin/tux将返回 /bin

sed: Sed是一个基本的查找替换程序。可以从标准输入（比如命令管道）读入文本，并将结果输出到标准输出（屏幕）。该命令采用正则表达式（见参考）进行搜索。不要和shell中的通配符相混淆。比如：将linuxfocus 替换为 LinuxFocus ：cat text.file | sed 's/linuxfocus/LinuxFocus/' > newtext.file

awk: awk 用来从文本文件中提取字段。缺省地，字段分割符是空格，可以使用-F指定其他分割符。cat file.txt | awk -F, '{print $1 "," $3 }'这里我们使用，作为字段分割符，同时打印第一个和第三个字段。如果该文件内容如下： Adam Bor, 34, IndiaKerry Miller, 22, USA命令输出结果为：Adam Bor, IndiaKerry Miller, USA

管道, 重定向和 backtick

> 写入文件并覆盖旧文件

>> 加到文件的尾部，保留旧文件内容。
```

## 3.1 awk

awk的语法有两种形式

```
awk [options] 'script' var=value file(s)

awk [options] -f scriptfile var=value file(s)
```

命令选项

```
-F fs or --field-separator fs
指定输入文件折分隔符，fs是一个字符串或者是一个正则表达式，如-F:。

-v var=value or --asign var=value
赋值一个用户定义变量。

-f scripfile or --file scriptfile
从脚本文件中读取awk命令。

-mf nnn and -mr nnn
对nnn值设置内在限制，-mf选项限制分配给nnn的最大块数目；-mr选项限制记录的最大数目。这两个功能是Bell实验室版awk的扩展功能，在标准awk中不适用。

-W compact or --compat, -W traditional or --traditional
在兼容模式下运行awk。所以gawk的行为和标准的awk完全一样，所有的awk扩展都被忽略。

-W copyleft or --copyleft, -W copyright or --copyright
打印简短的版权信息。

-W help or --help, -W usage or --usage
打印全部awk选项和每个选项的简短说明。

-W lint or --lint
打印不能向传统unix平台移植的结构的警告。

-W lint-old or --lint-old
打印关于不能向传统unix平台移植的结构的警告。

-W posix
打开兼容模式。但有以下限制，不识别：\x、函数关键字、func、换码序列以及当fs是一个空格时，将新行作为一个域分隔符；操作符**和**=不能代替^和^=；fflush无效。

-W re-interval or --re-inerval
允许间隔正则表达式的使用，参考(grep中的Posix字符类)，如括号表达式[[:alpha:]]。

-W source program-text or --source program-text
使用program-text作为源代码，可与-f命令混用。

-W version or --version
打印bug报告信息的版本。
```



## 4.Http

```
scp /test/test root@192.168.0.0:/root :传输文件
wget http://192.168.102.150:9005/marketing/activejob/wxgetJobs :get请求
```

## 5.服务

```
service --status-all  :查询所有服务
service sshd status   :查询单个服务
service 服务名 start   :启动
service 服务名 stop	:关闭
service 服务名 restart  :重启
centos7
    firewall-cmd --state :查看防火墙状态
    systemctl stop firewalld.service :关闭防火墙
centos6
    service iptables status  查看防火墙状态
    chkconfig iptables off   关闭防火墙
Ubuntu
    ufw status  查看防火墙状态
    ufw disable  关闭防火墙
free 
```

## 6.权限

```
chmod 755 *.*
```

## 7. yum

# 2.Mysql

1. 安装

```
创建 mysql 

docker run -p 3301:3306 --name mysql_3301 -v $PWD/root:/root -v $PWD/conf:/etc/mysql/conf.d -v $PWD/logs:/logs -v $PWD/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=116516 -d mysql

-p 3306:3306：将容器的 3306 端口映射到主机的 3306 端口。

-v -v $PWD/conf:/etc/mysql/conf.d：将主机当前目录下的 conf/my.cnf 挂载到容器的 /etc/mysql/my.cnf。

-v $PWD/logs:/logs：将主机当前目录下的 logs 目录挂载到容器的 /logs。

-v $PWD/data:/var/lib/mysql ：将主机当前目录下的data目录挂载到容器的 /var/lib/mysql 。

-e MYSQL_ROOT_PASSWORD=123456：初始化 root 用户的密码。

```



# 3.Nginx

# 4.Redis

1.安装

```
docker run -d -p 6371:6379 --name myredis
docker run -v /myredis/conf/redis.conf:/usr/local/etc/redis/redis.conf --name myredis redis redis-server /usr/local/etc/redis/redis.conf
```

​	源码安装过程

```
1.下载源码
wget http://...
2.解压
tar -xvf .....gz
3.编译(要C++ 的环境) 在源码目录下
make 
4.安装
make install
```



2.命令

系统命令

```
	查询服务器是否启动
	redis-cli -h 127.0.0.1 -p 6379 ping
	返回一个pong 表示服务正常 
	ping :测试服务是否正常 
	config get *   :查看所有参数
```

数据类型命令

通用命令

```
*      :
	del key [key...]		:删除一个key
	keys *		:查询所有的keys 支持正则 key过多会阻塞程序 全库扫
	dbsize  	:计算数据库的大小   	内置计数器
	exists key :判断key是否存在		存在 为1 不存在为0 
	expire key seconds :过期时间 秒
	ttl  key :查看key多久过期		返回 -1 为没有过期时间  -2 为已经过期  正数为剩余多少秒过期
	persist key ;取消key的过期
	type key :key的类型
 
```

String   :value值最大不能超过512MB

```
String :  
        set key value
        set key value nx :key不存在 设置key
        set key value xx :key存在 设置key
        mset key value [key value ....] :批量
        getset key value :设置一个新的value 返回旧的value
        append key value :在旧的value后面追加新的value
        setrange key index value :设置指定下标上的value 单个字符
        
        
        get key
        mget key [key...] :批量
        getrange key key start end :获得key指定start与end下标上的所有value
        
        incr key :自增
        drcr key :自减
        incrby key k :自增 增加K
        decrby key k :自减 减少K
        incrbyfloat key 3.5: key增加3.5
        
        
        strlen key 		:value  长度
```

hash	:

```
hset  key field  value
hmset key field  value[key field  value.....]

hget  key field
hmget key field [key field...]
hgetall key :返回所有 field value
hvals key :返回所有的value
hkeys key :返回所有的field

hdel  key field

hexists key field :判断field是否存在
hlen key :field的数量
```

list         :

```
rpush key value [value ....]  :从队列右端插入value
lpush key value [value ....]  :从队列左端插入value
linsert key <before/after> value newValue ;在队列中指定value[before前/after后] 插入新value

rpop key :从右端弹出一个value
lpop key :从左端弹出一个value

lrem key count value :删除指定的value 
	1. count > 0 从左到右删除count个相同value
	2. count < 0 从右到左删除count个相同value
	3. count = 0 删除所有相同value
	

```



3.配置

```
==基本配置
daemonize no 是否以后台进程启动
databases 16 创建database的数量(默认选中的是database 0)


save 900 1 #刷新快照到硬盘中，必须满足两者要求才会触发，即900秒之后至少1个关键字发生变化。
save 300 10 #必须是300秒之后至少10个关键字发生变化。
save 60 10000 #必须是60秒之后至少10000个关键字发生变化。
stop-writes-on-bgsave-error yes #后台存储错误停止写。
rdbcompression yes #使用LZF压缩rdb文件。
rdbchecksum yes #存储和加载rdb文件时校验。
dbfilename dump.rdb #设置rdb文件名。
dir ./ #设置工作目录，rdb文件会写入该目录。


==主从配置
slaveof <masterip> <masterport> 设为某台机器的从服务器
masterauth <master-password> 连接主服务器的密码
slave-serve-stale-data yes # 当主从断开或正在复制中,从服务器是否应答
slave-read-only yes #从服务器只读
repl-ping-slave-period 10 #从ping主的时间间隔,秒为单位
repl-timeout 60 #主从超时时间(超时认为断线了),要比period大
slave-priority 100 #如果master不能再正常工作，那么会在多个slave中，选择优先值最小的一个slave提升为master，优先值为0表示不能提升为master。

repl-disable-tcp-nodelay no #主端是否合并数据,大块发送给slave
slave-priority 100 从服务器的优先级,当主服挂了,会自动挑slave priority最小的为主服


===安全
requirepass foobared # 需要密码
rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52 #如果公共环境,可以重命名部分敏感命令 如config

 

===限制
maxclients 10000 #最大连接数
maxmemory <bytes> #最大使用内存

maxmemory-policy volatile-lru #内存到极限后的处理
volatile-lru -> LRU算法删除过期key
allkeys-lru -> LRU算法删除key(不区分过不过期)
volatile-random -> 随机删除过期key
allkeys-random -> 随机删除key(不区分过不过期)
volatile-ttl -> 删除快过期的key
noeviction -> 不删除,返回错误信息

#解释 LRU ttl都是近似算法,可以选N个,再比较最适宜T踢出的数据
maxmemory-samples 3

====日志模式
appendonly no #是否仅要日志
appendfsync no # 系统缓冲,统一写,速度快
appendfsync always # 系统不缓冲,直接写,慢,丢失数据少
appendfsync everysec #折衷,每秒写1次

no-appendfsync-on-rewrite no #为yes,则其他线程的数据放内存里,合并写入(速度快,容易丢失的多)
auto-AOF-rewrite-percentage 100 当前aof文件是上次重写是大N%时重写
auto-AOF-rewrite-min-size 64mb aof重写至少要达到的大小

====慢查询
slowlog-log-slower-than 10000 #记录响应时间大于10000微秒的慢查询
slowlog-max-len 128 # 最多记录128条


====服务端命令
time 返回时间戳+微秒
dbsize 返回key的数量
bgrewriteaof 重写aof
bgsave 后台开启子进程dump数据
save 阻塞进程dump数据
lastsave

slaveof host port 做host port的从服务器(数据清空,复制新主内容)
slaveof no one 变成主服务器(原数据不丢失,一般用于主服失败后)

flushdb 清空当前数据库的所有数据
flushall 清空所有数据库的所有数据(误用了怎么办?)

shutdown [save/nosave] 关闭服务器,保存数据,修改AOF(如果设置)

slowlog get 获取慢查询日志
slowlog len 获取慢查询日志条数
slowlog reset 清空慢查询


info []

config get 选项(支持*通配)
config set 选项 值
config rewrite 把值写到配置文件
config restart 更新info命令的信息

debug object key #调试选项,看一个key的情况
debug segfault #模拟段错误,让服务器崩溃
object key (refcount|encoding|idletime)
monitor #打开控制台,观察命令(调试用)
client list #列出所有连接
client kill #杀死某个连接 CLIENT KILL 127.0.0.1:43501
client getname #获取连接的名称 默认nil
client setname "名称" #设置连接名称,便于调试

 

====连接命令===
auth 密码 #密码登陆(如果有密码)
ping #测试服务器是否可用
echo "some content" #测试服务器是否正常交互
select 0/1/2... #选择数据库
quit #退出连接
```



# 5.frame

## 1.Spring

### 1.SpringBoot

### 2.SpringCloud

### 3.Spring Data

## 2.Mybatis

# 6.JMS

## 1.ActiveMQ

## 2.RabbitMQ

## 3.kafka

# 7.Http

# 8.Docker

​	 启动化运维工具,可以在Linux系统上,创建Linux系统的虚拟机,并且创建服务

​	操作命令

**状态**

```
docker ps :查看正在运行的容器
docker ps –a :查看所有容器
docker ps –l :查看最后一次运行的容器
docker ps -f status=exited :查看停止的容器
```

**镜像**

```
docker images  :查看所有镜像
    REPOSITORY：镜像名称
    TAG：镜像标签
    IMAGE ID：镜像ID
    CREATED：镜像的创建日期（不是获取该镜像的日期）
    SIZE：镜像大小
    镜像存放位置:/var/lib/docker
docker search 镜像名称  :搜索镜像
	NAME：仓库名称
    DESCRIPTION：镜像描述
    STARS：用户评价，反应一个镜像的受欢迎程度
    OFFICIAL：是否官方
    AUTOMATED：自动构建，表示该镜像由Docker Hub自动构建流程创建的
docker pull 镜像名称:版本 :拉取镜像 
docker rmi 镜像ID    :删除镜像
```

**容器**

```
docker run :创建容器
 -i：表示运行容器
 -t：表示容器启动后会进入其命令行。加入这两个参数后，容器创建就能登录进去。即分配一个伪终端。
 --name :为创建的容器命名。
 -v：表示目录映射关系（前者是宿主机目录，后者是映射到宿主机上的目录），可以使用多个－v做多个目录或文件映射。注意：最好做目录映射，在宿主机上做修改，然后共享到容器上。
 -d：在run后面加上-d参数,则会创建一个守护式容器在后台运行（这样创建容器后不会自动登录容器，如果只加-i -t两个参数，创建后就会自动进去容器）。
 -p：表示端口映射，前者是宿主机端口，后者是容器内的映射端口。可以使用多个-p做多个端口映射
1.交互式方式创建容器:标签是latest 则可以省略
	docker run -it --name=容器名称 镜像名称:标签 /bin/bash
2.守护式方式创建容器：
	docker run -di --name=容器名称 镜像名称:标签
	
docker stop 容器名称（或者容器ID）   关闭容器
docker start 容器名称（或者容器ID）  启动容器
docker rm 容器名称（容器ID）	    删除容器

sudo docker attach 44fc0f0582d9  :进入容器  进入交互式容器
sudo docker exec -it 容器名称 (或者容器ID)  /bin/bash :进入守护式容器


docker cp 需要拷贝的文件或目录 容器名称:容器目录 		拷贝文件
docker cp 容器名称:容器目录 需要拷贝的文件或目录		

docker inspect 容器名称（容器ID） 	:查看容器参数
docker inspect --format='{{.NetworkSettings.IPAddress}}' 容器名称（容器ID）
```

**镜像保存创建**

```
docker commit 容器名 镜像名 :将容器保存为镜像
docker  save -o mynginx.tar 镜像名:将镜像保存为tar 文件
docker load -i mynginx.tar  :恢复镜像
docker build -t redis:3.0.7:
```

​	