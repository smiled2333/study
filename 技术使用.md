# 1.Linux

## 1.网络

```route
route :设置路由
	Route命令是用于操作基于内核ip路由表，它的主要作用是创建一个静态路由让指定一个主机或者一个网络通过一个网络接口，如eth0。当使用"add"或者"del"参数时，路由表被修改，如果没有参数，则显示路由表当前的内容。
1.格式: 
route [-f] [-p] [Command [Destination] [mask Netmask] [Gateway] [metric Metric]] [if Interface]] 
2.参数
-c 显示更多信息
-n 不解析名字
-v 显示详细的处理信息
-F 显示发送信息
-C 显示路由缓存
-f 清除所有网关入口的路由表。 
-p 与 add 命令一起使用时使路由具有永久性。
add:添加一条新路由。
del:删除一条路由。
-net:目标地址是一个网络。
-host:目标地址是一个主机。
netmask:当添加一个网络路由时，需要使用网络掩码。
gw:路由数据包通过网关。注意，你指定的网关必须能够达到。
metric：设置路由跳数。
Command 指定您想运行的命令 (Add/Change/Delete/Print)。 
Destination 指定该路由的网络目标。 
mask Netmask 指定与网络目标相关的网络掩码（也被称作子网掩码）。 
Gateway 指定网络目标定义的地址集和子网掩码可以到达的前进或下一跃点 IP 地址。 
metric Metric 为路由指定一个整数成本值标（从 1 至 9999），当在路由表(与转发的数据包目标地址最匹配)的多个路由中进行选择时可以使用。 
if Interface 为可以访问目标的接口指定接口索引。若要获得一个接口列表和它们相应的接口索引，使用 route print 命令的显示功能。可以使用十进制或十六进制值进行接口索引。
3.使用实例
route -n  :查询所有路由信息
route add -net 224.0.0.0 netmask 240.0.0.0 dev eth0 :添加一个网关
route del -net 224.0.0.0 netmask 240.0.0.0 :删除一个路由记录
route add -net 192.168.0.1 netmask 255.255.255.0 gw192.168.1.1 :将0网段的请求路由到1网段上
```

```
ifconfig :查询ip信息
netstat  :查询网络状态
	-t：列出TCP协议端口
　　-u：列出UDP协议端口
　　-n：不使用域名与服务名，而使用IP地址和端口号
　　-l ：仅列出在监听状态网络服务（只有TCP有监听状态）
　　-a：列出所有网络连接
　　-r ：列出路由列表，功能和route命令一致
测试
    ping      :命令 
    telnet    :命令 telnet  [域名或者IP]  [端口]
    trceroute :命令 traceroute  [选项]  IP或域名
		-n：使用IP，不使用域名，速度更快。
wget 	:下载
	 wget http://soft.vpser.net/lnmp1.1-full.tar.gz
```
## 2.文件

```find
find / -name test.txt :查询根目录下 文件与文件夹名字为 test.txt
cat :打开文件
vim :编辑文件
tail:浏览文件 
	-f 动态更新文件
	-n 指定浏览文件后多少行文件
rm :删除
cp :复制
cp /test1/file1 /test3/file2:将file1 文件移动到test3下 并改名为file2
mv :移动
mv /test1/file1 /test3/file2:..
tar :文件压缩解压
    -c: 建立压缩档案
    -x：解压
    -t：查看内容
    -r：向压缩归档文件末尾追加文件
    -u：更新原压缩包中的文件
    以上一次只能使用一个
    -z：有gzip属性的
    -j：有bz2属性的
    -Z：有compress属性的
    -v：显示所有过程
    -O：将文件解开到标准输出
    -f: 是必须的
压缩
 	tar -cvf jpg.tar *.jpg //将目录里所有jpg文件打包成jpg.tar 
解压
	tar -xvf file.tar //解压 tar包
mkdir :
　　-p　　如果目录已经存在，则不会有错误提示。若父目录不存在，将会创建父目录。该选项常用于创建级联目录。
　　-v　　为每个目录显示提示信息。
mkdir 777 test 创建文件夹并赋予最高权限
mkdir test 创建文件夹
```

## 3.shell

格式 

```
#!/bin/sh       # 必须在文件的第一行 表示文件是可以执行的
```

### 1.变量的定义

1.变量名与变量之间不能存在空格
2.使用一个已经定义过的变量，只需要在变量的名字前加$
3.定义为读取的变量,所有变量通用

```shell  
name='leeguo'
readonly name
```
4.删除变量内容,所有变量通用
```shell
name='idealcitier'
unset name
```
5.全局变量
```shell
export NAME=idealcitier
env | grep NAME
```
6.普通变量
```shell
key=value
```
7.内变量

```shell
$0 获取当前执行的shell脚本文件名
$n 获取当前执行的shell脚本的第n个参数值，n=1..9，当n为0时表示脚本的文件名，如果n大于9就要用大 括号括起来${10}
$# 获取当前shell命令行中参数的总个数
$? 获取执行上一个指令的返回值（0为成功，非0为失败）
$* 获得全部参数
```



### 2.字符串

    1. 单引号
    单引号中所有的字符都是原样的输出，也就是说单引号中的变量是无效的。
    单引号中无能再出现单引号了，对转移符也无效
    2. 双引号
    双引号中可以有变量
    可以使用转移符
```shell
str='test line'
echo 'It is a $str '

echo "It is a \" $str \""
#output
It is a $str
It is a " test line "
```
    3. 拼接字符串
```shell
your_name="qinjx"
greeting="hello, "$your_name" !"
greeting_1="hello, ${your_name} !"
echo $greeting $greeting_1
```
    4. 获取字符串长度
```shell
string="abcd"
echo ${#string} #输出 4
```
    5. 提取子字符串
```shell
提取 指定长度字符串 
string=abc12342341    #等号二边不要有空格  
echo ${string:4}      #2342341  从第4位开始截取后面所有字符串    
echo ${string:3:3}    #123      从第3位开始截取后面3位    
echo ${string:3:6}    #123423   从第3位开始截取后面6位    
echo ${string: -4}    #2341  ：右边有空格   截取后4位    
echo ${string:(-4)}   #2341  同上    
expr substr $string 3 3   #c12  从第3位开始截取后面3位    
expr match $string '\([a-c]*[0-9]*\)'  #abc12342341    
expr $string : '\([a-c]*[0-9]\)'       #abc1    
expr $string : '.*\([0-9][0-9][0-9]\)' #341 显示括号中匹配的内容   
echo ${string#a*3}     #42341  从$string左边开始，去掉最短匹配子串    
echo ${string#c*3}     #abc12342341  这样什么也没有匹配到    
echo ${string#*c1*3}   #42341  从$string左边开始，去掉最短匹配子串    
echo ${string##a*3}    #41     从$string左边开始，去掉最长匹配子串    
echo ${string%3*1}     #abc12342  从$string右边开始，去掉最短匹配子串    
echo ${string%%3*1}    #abc12     从$string右边开始，去掉最长匹配子串   

string="runoob is a great site"
expr substr ${string} 1 4

#按照指定要求分割：
ls -al | cut -d "." -f2 


#匹配并且替换 ${变量/查找/替换值}
echo ${string/23/bb}   #abc1bb42341  替换一次    
echo ${string//23/bb}  #abc1bb4bb41  双斜杠替换所有匹配    
echo ${string/#abc/bb} #bb12342341   #以什么开头来匹配，根php中的^有点像    
echo ${string/%41/bb}  #abc123423bb  %以什么结尾来匹配，根php中的$有点像   

#比较
[[ "a.txt" == a* ]]        # 逻辑真 (pattern matching)  
[[ "a.txt" =~ .*\.txt ]]   # 逻辑真 (regex matching)  
[[ "abc" == "abc" ]]       # 逻辑真 (string comparision)   
[[ "11" < "2" ]]           # 逻辑真 (string comparision), 按ascii值比较  

#删除
#${变量名#substring正则表达式}从字符串开头开始匹配substring,删除匹配上的表达式。 
#${变量名%substring正则表达式}从字符串结尾开始匹配substring,删除匹配上的表达式。 
#注意：${test##*/},${test%/*} 分别是得到文件名，或者目录地址最简单方法。   
从左向右截取最后一个string后的字符串
${varible##*string}
从左向右截取第一个string后的字符串
${varible#*string}
从右向左截取最后一个string后的字符串
${varible%%*string}
从右向左截取第一个string后的字符串
${varible%*string}
"*"只是一个通配符可以不要

```
    6. 查找子字符串
```shell
string="runoob is a great company"
echo `expr index "$string" is`  # 输出 8
```


### 3. 数组

  支持一维数组（不支持多维数组），并且没有限定数组的大小。 从0开始
	1. 定义格式
```shell
数组名=(值1 值2 … 值n) :以空格区分
array_name[0]=value0
array_name[1]=value1
array_name[n]=valuen
```
2. 读取数组

```shell
1.获得单个value
{数组名[下标]},也就是valuen={array_name[n]}
echo ${array_name[@]}
```
​	2.取得数组元素的个数

```shell
length=${#array_name[@]}
length=${#array_name[*]}
```
​	3.取得数组单个元素的长度

```shell
lengthn=${#array_name[n]}
```
### 4. 运算
使用 expr、$[ ]、let等整数运算工具：
	定义变量X=1234，然后计算X与78的四则运算及求模结果
	使用bc实现小数运算操作：以交互方式计算12.34与56.78的四则运算结果，另外再以非交互方式重复上述计算，最多显示4位小数
#### 1.expr
```shell
X=1234
expr $X + 78
expr $X - 78  
expr $X \* 78
expr $X / 78
expr $X % 78 
```
#### 2.$[ ]  :表达式
```shell
X=1234
echo $[X+78]
echo $[X-78]
echo $[X*78]
echo $[X/78]
echo $[X%78]
```
#### 3.let  可以保持到变量中
```shell
X=1234
let y=X+22
echo $y
let X+=78 ; echo $X                 # X+=78(X=X+78)
let X-=78 ; echo $X                 # X-=78(X=X-78)
let X*=78 ; echo $X                 # X*=78(X=X*78)
let X/=78 ; echo $X                 # X/=78(X=X/78)
let X%=78 ; echo $X                 # X%=78(X=X%79)
```
#### 4.判断   
查看结果0为对，非0为错
```shell
1.== 比较两个字符串是否相同
	 [ $USER == "root" ]
2.!= 比较两个字符串是否不相同
	[ $USER != "root" ]
3.-z 检查变量的值是否未设置（空值）
	[ -z "$user" ]
	[ ! -z $var1 ]                //测试var1是否为非空
4.整数值比较 比较非整数值时会出错 可以调用变量
	1. -eq 比较两个数是否相等	=
		[ $X -eq 20 ] && echo "相等" || echo "不相等"
	2. -ne 比较两个数是否不相等  !=
	3. -gt 比较前面的整数是否大于后面的整数  >
	4. -ge 比较前面的整数是否大于或等于后面的整数。 >=
	5. -lt 比较前面的整数是否小于后面的整数     <
	6. -le 比较前面的整数是否小于或等于后面的整数  <=
5.识别文件/目录的状态
    1.	-e 判断对象是否存在（不管是目录还是文件）
    	[ -e "/etc/fstab" ] && echo "存在" || echo "不存在"
    2.	-d 判断对象是否为目录（存在且是目录）
    3.	-f 判断对象是否为文件（存在且是文件）
    4.	-r 判断对象是否可读
    5.	-w 判断对象是否可写
    6.	-x 判断对象是否具有可执行权限
6. 多个条件/操作的逻辑组合
	1. 检查变量X的值是否大于10，且小于30
		[ $X -gt 10 ] && [ $X -lt 30 ] && echo "YES"
	2.  多个条件组合时，可以使用 [[ .. ]] 界定，比如上述测试可以改为如下
		[[ $X -gt 10 && $X -lt 30 ]] && echo "YES"
	3.  ||，逻辑或
		[[ $X -lt 10 || $X -lt 30 ]] && echo "YES"
```
### 5.语句

```shell
exit n 脚本退出 
break 退出当前循环 
continue 提前结束内部循环（当前循环），然后进入下一次循环
```



```shell
 if [ ! 1 -eq 1 ]; then
        echo 3
    elif [ 2=2 ]; then
        echo 1
    elif [ 2=2 ]; then
        echo 1
    else
        echo 2
    fi
```

```shell
    for (( VAR = 0; VAR < 10; ++VAR )); do
        echo $VAR
    done

    for VAR in item1 item2 item3 ; do
        echo $VAR
    done
    
    for NUM in {1..3}  #{1..3}的意思是1到3
    for NUM  in 1 2 3 #NUM 为1、2、3、
    for NUM in  `seq 1 3` #比如NUM是1到3时
    for NUM in `seq 1 2 10` #1-10里面的每隔2个显示
    for NUM in $list
```

```shell
    case $1 in			
            1)			#当$1是1 输出 1
            echo 1
            ;;
            2)			#当$1是2 输出 2
            echo 2
            ;;
    esac
```

```shell
set timeout 30  # 设置会话超时时间为30s, 若不限制超时时间则应设置为-1
spawn 后面跟一个命令，开启一个会话
expect 接收命令执行后的输出，然后和期望字符串匹配，若对应这执行相应的send来发送交互信息。
 expect "$case1" {send "$respond1\r"} # 这一行等同于下面两行
 expect "$case1"
 send "$response1\r"
 expect 可以有多个分支，就像switch语句一样。
 expect 
 {
    "$case1" {send "$response1\r"}
    "$case2" {send "$response2\r"}
    "$case3" {send "$response3\r"}
 }
 expect eof #：等待执行结束，若没有这一句，可能导致命令还没执行，脚本就结束了
 interact #： 执行完成后保持交互状态, 这时可以手动输入信息
 #注：expect eof 与 interact 二选一即可
```

### 6.关键字

```
echo 变量/字符串  #打印
export  #处理过的变量叫做环境变量,通常情况下仅仅在登录脚本中使用环境变量
read 变量名 :
sleep 1 ;暂停1秒
expr  :执行函数使用
```

### 7.花里胡哨的使用

```shell
echo 输出内容 带颜色

```



命令 

```
Unix 命令 linux系统当值的命令 #这些命令通常是用来进行文件和文字操作的。

echo "some text": 将文字内容打印在屏幕上

wc –l filewc -w filewc -c file: 计算文件行数计算文件中的单词数计算文件中的字符数

grep 'pattern' file: 在文件内搜索字符串比如：grep 'searchstring' file.txt

cut -b colnum file: 指定欲显示的文件内容范围，并将它们输出到标准输出设备比如：输出每行第5个到第9个字符cut -b5-9 file.txt千万不要和cat命令混淆，这是两个完全不同的命令

file somefile: 得到文件类型

read var: 提示用户输入，并将输入赋值给变量

sort file.txt: 对file.txt文件中的行进行排序

uniq: 删除文本文件中出现的行列比如： sort file.txt | uniq

expr: 进行数学运算Example: add 2 and 3expr 2 "+" 3

find: 搜索文件比如：根据文件名搜索find . -name filename -print

tee: 将数据输出到标准输出设备(屏幕) 和文件比如：somecommand | tee outfile
　
basename file: 返回不包含路径的文件名比如： basename /bin/tux将返回 tux

dirname file: 返回文件所在路径比如：dirname /bin/tux将返回 /bin

sed: Sed是一个基本的查找替换程序。可以从标准输入（比如命令管道）读入文本，并将结果输出到标准输出（屏幕）。该命令采用正则表达式（见参考）进行搜索。不要和shell中的通配符相混淆。比如：将linuxfocus 替换为 LinuxFocus ：cat text.file | sed 's/linuxfocus/LinuxFocus/' > newtext.file

awk: awk 用来从文本文件中提取字段。缺省地，字段分割符是空格，可以使用-F指定其他分割符。cat file.txt | awk -F, '{print $1 "," $3 }'这里我们使用，作为字段分割符，同时打印第一个和第三个字段。如果该文件内容如下： Adam Bor, 34, IndiaKerry Miller, 22, USA命令输出结果为：Adam Bor, IndiaKerry Miller, USA

管道, 重定向和 backtick

> 写入文件并覆盖旧文件

>> 加到文件的尾部，保留旧文件内容。
```

7.函数

```shell
name(){
    
}
function  name(){
    return 1
}
#调用语法
#         函数名   参数1   参数2 ....
#函数中的变量
#          均为全局变量，没有局部变量
#函数的调用
#          可以传递参数，在函数中用$1,$2, $3...来引用传递的参数。

#返回值获得
#第1种 echo..
name=`main 1 2`  #获得函数全部打印输出数据结构
#第2种 return
main 1 2
name=$?  #将上一条的命令的结果赋值给name变量
```





### 3.1 awk

awk的语法有两种形式

```
awk [options] 'script' var=value file(s)

awk [options] -f scriptfile var=value file(s)
```

命令选项

```
-F fs or --field-separator fs
指定输入文件折分隔符，fs是一个字符串或者是一个正则表达式，如-F:。

-v var=value or --asign var=value
赋值一个用户定义变量。

-f scripfile or --file scriptfile
从脚本文件中读取awk命令。

-mf nnn and -mr nnn
对nnn值设置内在限制，-mf选项限制分配给nnn的最大块数目；-mr选项限制记录的最大数目。这两个功能是Bell实验室版awk的扩展功能，在标准awk中不适用。

-W compact or --compat, -W traditional or --traditional
在兼容模式下运行awk。所以gawk的行为和标准的awk完全一样，所有的awk扩展都被忽略。

-W copyleft or --copyleft, -W copyright or --copyright
打印简短的版权信息。

-W help or --help, -W usage or --usage
打印全部awk选项和每个选项的简短说明。

-W lint or --lint
打印不能向传统unix平台移植的结构的警告。

-W lint-old or --lint-old
打印关于不能向传统unix平台移植的结构的警告。

-W posix
打开兼容模式。但有以下限制，不识别：\x、函数关键字、func、换码序列以及当fs是一个空格时，将新行作为一个域分隔符；操作符**和**=不能代替^和^=；fflush无效。

-W re-interval or --re-inerval
允许间隔正则表达式的使用，参考(grep中的Posix字符类)，如括号表达式[[:alpha:]]。

-W source program-text or --source program-text
使用program-text作为源代码，可与-f命令混用。

-W version or --version
打印bug报告信息的版本。
```



## 4.Http

```
scp /test/test root@192.168.0.0:/root :传输文件
wget http://192.168.102.150:9005/marketing/activejob/wxgetJobs :get请求
```

## 5.服务

```
service --status-all  :查询所有服务
service sshd status   :查询单个服务
service 服务名 start   :启动
service 服务名 stop	:关闭
service 服务名 restart  :重启
centos7
    firewall-cmd --state :查看防火墙状态
    systemctl stop firewalld.service :关闭防火墙
centos6
    service iptables status  查看防火墙状态
    chkconfig iptables off   关闭防火墙
Ubuntu
    ufw status  查看防火墙状态
    ufw disable  关闭防火墙
free 
```

## 6.权限

```
chmod 755 *.*
```

## 7. yum

# 2.Mysql

1. 安装

```
创建 mysql 

docker run -p 3301:3306 --name mysql_3301 -v $PWD/root:/root -v $PWD/conf:/etc/mysql/conf.d -v $PWD/logs:/logs -v $PWD/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=116516 -d mysql

-p 3306:3306：将容器的 3306 端口映射到主机的 3306 端口。

-v -v $PWD/conf:/etc/mysql/conf.d：将主机当前目录下的 conf/my.cnf 挂载到容器的 /etc/mysql/my.cnf。

-v $PWD/logs:/logs：将主机当前目录下的 logs 目录挂载到容器的 /logs。

-v $PWD/data:/var/lib/mysql ：将主机当前目录下的data目录挂载到容器的 /var/lib/mysql 。

-e MYSQL_ROOT_PASSWORD=123456：初始化 root 用户的密码。

```



# 3.Nginx

# 4.Redis

1.安装

```
docker run -d -p 6371:6379 --name myredis
docker run -v /myredis/conf/redis.conf:/usr/local/etc/redis/redis.conf --name myredis redis redis-server /usr/local/etc/redis/redis.conf
```

​	源码安装过程

```
1.下载源码
wget http://...
2.解压
tar -xvf .....gz
3.编译(要C++ 的环境) 在源码目录下
make 
4.安装
make install
```



2.命令

系统命令

```
	查询服务器是否启动
	redis-cli -h 127.0.0.1 -p 6379 ping
	返回一个pong 表示服务正常 
	ping :测试服务是否正常 
	config get *   :查看所有参数
```

数据类型命令

通用命令

```
*      :
	del key [key...]		:删除一个key
	keys *		:查询所有的keys 支持正则 key过多会阻塞程序 全库扫
	dbsize  	:计算数据库的大小   	内置计数器
	exists key :判断key是否存在		存在 为1 不存在为0 
	expire key seconds :过期时间 秒
	ttl  key :查看key多久过期		返回 -1 为没有过期时间  -2 为已经过期  正数为剩余多少秒过期
	persist key ;取消key的过期
	type key :key的类型
 
```

String   :value值最大不能超过512MB

```
String :  
        set key value
        set key value nx :key不存在 设置key
        set key value xx :key存在 设置key
        mset key value [key value ....] :批量
        getset key value :设置一个新的value 返回旧的value
        append key value :在旧的value后面追加新的value
        setrange key index value :设置指定下标上的value 单个字符
        
        
        get key
        mget key [key...] :批量
        getrange key key start end :获得key指定start与end下标上的所有value
        
        incr key :自增
        drcr key :自减
        incrby key k :自增 增加K
        decrby key k :自减 减少K
        incrbyfloat key 3.5: key增加3.5
        
        
        strlen key 		:value  长度
```

hash	:

```
hset  key field  value
hmset key field  value[key field  value.....]

hget  key field
hmget key field [key field...]
hgetall key :返回所有 field value
hvals key :返回所有的value
hkeys key :返回所有的field

hdel  key field

hexists key field :判断field是否存在
hlen key :field的数量
```

list         :

```
rpush key value [value ....]  :从队列右端插入value
lpush key value [value ....]  :从队列左端插入value
linsert key <before/after> value newValue :在队列中指定value[before前/after后] 插入新value

rpop key :从右端弹出一个value
brpop key timeout::阻塞弹出,当List为空时,可以指定阻塞时间来,等待List的元素加入

lpop key :从左端弹出一个value
blpop key timeout(秒):阻塞弹出,当List为空时,可以指定阻塞时间来,等待List的元素加入
lrem key count value :删除指定的value 
	1. count > 0 从左到右删除count个相同value
	2. count < 0 从右到左删除count个相同value
	3. count = 0 删除所有相同value

ltrim key start end  :按照索引范围修剪列表

lrange key start end :按照缩影返回获得列表
		0-正数,是从左到右
		-1-到负数 是从右到左
		0- -1  是获得全部
lindex key index :指定获得元素

llen key :列表长度

lset key index newValue :替换



```

set

```redis
sadd key value
srem key value 

scard key :大小
sismember key value :存在1 不存在0
srandmember key count:随机在Set中取出count个元素 不删除
spop key :随机弹出一个元素 删除
smembers key :取出所有元素


# 差集   sdiff  以key1 为准 与其他key比较 将在key1中 并且其他key中没有元素取出
sdiff key1 key2 [key...] : 
# 交集	sinter  所有key中都存在的元素取出
sinter key1 key2 [key...]:
# 并集 sunion 	将所有key中的元素取出一份
sunion key1 key2 [key...] 

```

zSet

```redis
zadd key score value :score 分数 由小到大 分数可以重复
zrem key value [value...]
zscore key value :返回分数

zincrby key count(正负) value :对key中value的score增加count
zcard key :个数
zrank key value :获得value在key中可以在排名 从0开始

zrange key start end [withscores]:按元素排名范围取出元素与[分数]
zrangebyscore key minscore maxscore [withscores] :按分数范围取出元素与[分数]

zcount key minscore maxscore :
```





3.配置

```
==基本配置
daemonize no 是否以后台进程启动
databases 16 创建database的数量(默认选中的是database 0)


save 900 1 #刷新快照到硬盘中，必须满足两者要求才会触发，即900秒之后至少1个关键字发生变化。
save 300 10 #必须是300秒之后至少10个关键字发生变化。
save 60 10000 #必须是60秒之后至少10000个关键字发生变化。
stop-writes-on-bgsave-error yes #后台存储错误停止写。
rdbcompression yes #使用LZF压缩rdb文件。
rdbchecksum yes #存储和加载rdb文件时校验。
dbfilename dump.rdb #设置rdb文件名。
dir ./ #设置工作目录，rdb文件会写入该目录。


==主从配置
slaveof <masterip> <masterport> 设为某台机器的从服务器
masterauth <master-password> 连接主服务器的密码
slave-serve-stale-data yes # 当主从断开或正在复制中,从服务器是否应答
slave-read-only yes #从服务器只读
repl-ping-slave-period 10 #从ping主的时间间隔,秒为单位
repl-timeout 60 #主从超时时间(超时认为断线了),要比period大
slave-priority 100 #如果master不能再正常工作，那么会在多个slave中，选择优先值最小的一个slave提升为master，优先值为0表示不能提升为master。

repl-disable-tcp-nodelay no #主端是否合并数据,大块发送给slave
slave-priority 100 从服务器的优先级,当主服挂了,会自动挑slave priority最小的为主服


===安全
requirepass foobared # 需要密码
rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52 #如果公共环境,可以重命名部分敏感命令 如config

 

===限制
maxclients 10000 #最大连接数
maxmemory <bytes> #最大使用内存

maxmemory-policy volatile-lru #内存到极限后的处理
volatile-lru -> LRU算法删除过期key
allkeys-lru -> LRU算法删除key(不区分过不过期)
volatile-random -> 随机删除过期key
allkeys-random -> 随机删除key(不区分过不过期)
volatile-ttl -> 删除快过期的key
noeviction -> 不删除,返回错误信息

#解释 LRU ttl都是近似算法,可以选N个,再比较最适宜T踢出的数据
maxmemory-samples 3

====日志模式
appendonly no #是否仅要日志
appendfsync no # 系统缓冲,统一写,速度快
appendfsync always # 系统不缓冲,直接写,慢,丢失数据少
appendfsync everysec #折衷,每秒写1次

no-appendfsync-on-rewrite no #为yes,则其他线程的数据放内存里,合并写入(速度快,容易丢失的多)
auto-AOF-rewrite-percentage 100 当前aof文件是上次重写是大N%时重写
auto-AOF-rewrite-min-size 64mb aof重写至少要达到的大小

====慢查询
slowlog-log-slower-than 10000 #记录响应时间大于10000微秒的慢查询
slowlog-max-len 128 # 最多记录128条


====服务端命令
time 返回时间戳+微秒
dbsize 返回key的数量
bgrewriteaof 重写aof
bgsave 后台开启子进程dump数据
save 阻塞进程dump数据
lastsave

slaveof host port 做host port的从服务器(数据清空,复制新主内容)
slaveof no one 变成主服务器(原数据不丢失,一般用于主服失败后)

flushdb 清空当前数据库的所有数据
flushall 清空所有数据库的所有数据(误用了怎么办?)

shutdown [save/nosave] 关闭服务器,保存数据,修改AOF(如果设置)

slowlog get 获取慢查询日志
slowlog len 获取慢查询日志条数
slowlog reset 清空慢查询


info []

config get 选项(支持*通配)
config set 选项 值
config rewrite 把值写到配置文件
config restart 更新info命令的信息

debug object key #调试选项,看一个key的情况
debug segfault #模拟段错误,让服务器崩溃
object key (refcount|encoding|idletime)
monitor #打开控制台,观察命令(调试用)
client list #列出所有连接
client kill #杀死某个连接 CLIENT KILL 127.0.0.1:43501
client getname #获取连接的名称 默认nil
client setname "名称" #设置连接名称,便于调试

 

====连接命令===
auth 密码 #密码登陆(如果有密码)
ping #测试服务器是否可用
echo "some content" #测试服务器是否正常交互
select 0/1/2... #选择数据库
quit #退出连接
```



# 5.frame

## 1.Spring

### 1.SpringBoot

### 2.SpringCloud

### 3.Spring Data

## 2.Mybatis

# 6.JMS

## 1.ActiveMQ

## 2.RabbitMQ

## 3.kafka

# 7.Http

# 8.Docker

​	 启动化运维工具,可以在Linux系统上,创建Linux系统的虚拟机,并且创建服务

​	操作命令

**状态**

```
docker ps :查看正在运行的容器
docker ps –a :查看所有容器
docker ps –l :查看最后一次运行的容器
docker ps -f status=exited :查看停止的容器
```

**镜像**

```
docker images  :查看所有镜像
    REPOSITORY：镜像名称
    TAG：镜像标签
    IMAGE ID：镜像ID
    CREATED：镜像的创建日期（不是获取该镜像的日期）
    SIZE：镜像大小
    镜像存放位置:/var/lib/docker
docker search 镜像名称  :搜索镜像
	NAME：仓库名称
    DESCRIPTION：镜像描述
    STARS：用户评价，反应一个镜像的受欢迎程度
    OFFICIAL：是否官方
    AUTOMATED：自动构建，表示该镜像由Docker Hub自动构建流程创建的
docker pull 镜像名称:版本 :拉取镜像 
docker rmi 镜像ID    :删除镜像
```

**容器**

```
docker run :创建容器
 -i：表示运行容器
 -t：表示容器启动后会进入其命令行。加入这两个参数后，容器创建就能登录进去。即分配一个伪终端。
 --name :为创建的容器命名。
 -v：表示目录映射关系（前者是宿主机目录，后者是映射到宿主机上的目录），可以使用多个－v做多个目录或文件映射。注意：最好做目录映射，在宿主机上做修改，然后共享到容器上。
 -d：在run后面加上-d参数,则会创建一个守护式容器在后台运行（这样创建容器后不会自动登录容器，如果只加-i -t两个参数，创建后就会自动进去容器）。
 -p：表示端口映射，前者是宿主机端口，后者是容器内的映射端口。可以使用多个-p做多个端口映射
1.交互式方式创建容器:标签是latest 则可以省略
	docker run -it --name=容器名称 镜像名称:标签 /bin/bash
2.守护式方式创建容器：
	docker run -di --name=容器名称 镜像名称:标签
	
docker stop 容器名称（或者容器ID）   关闭容器
docker start 容器名称（或者容器ID）  启动容器
docker rm 容器名称（容器ID）	    删除容器

sudo docker attach 44fc0f0582d9  :进入容器  进入交互式容器
sudo docker exec -it 容器名称 (或者容器ID)  /bin/bash :进入守护式容器


docker cp 需要拷贝的文件或目录 容器名称:容器目录 		拷贝文件
docker cp 容器名称:容器目录 需要拷贝的文件或目录		

docker inspect 容器名称（容器ID） 	:查看容器参数
docker inspect --format='{{.NetworkSettings.IPAddress}}' 容器名称（容器ID）
```

**镜像保存创建**

```
docker commit 容器名 镜像名 :将容器保存为镜像
docker  save -o mynginx.tar 镜像名:将镜像保存为tar 文件
docker load -i mynginx.tar  :恢复镜像
docker build -t redis:3.0.7:
```

​	