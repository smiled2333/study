# 1.jvm
##	1.1 Java虚拟机
>1.HotSpot sun公司默认使用的JVM
	1.不区分本地方法栈和虚拟机栈

##	1.2 Java内存区域

![](.\java内存区域.png)

**1.线程独占区**
	1.1.堆
		所有创建的对象实例都会在堆中创建,开辟内存空间
	1.2.方法区
		存放类的类型信息(成员变量,成员方法,静态变量,静态方法,类的字节码信息)
	类的版本,字段,方法,接口等信息
**2.线程共享去**
	2.1.虚拟机栈
		用于执行Java方法,每一个方法进栈,都会创建一个栈针,当方法执行完成,则栈针出栈
	2.2.本地方法栈
		用于执行native方法, 
	2.3.程序计数器
		用于记录程序执行行数
**3.直接内存与运行时常量池**
	3.1.直接内存
		java程序会使用的总的内存
	3.2.运行时常量池
		运行时常量池是在方法区中,存放编译期间生成的自变量和符号应用的
## 1.3 对象
**1.3.1.对象的创建**
![](.\java对象的创建.png)

> 1.内存分配
> 1.1.指针碰撞
> 	将类创建的内存区域中增加一个指针,指针两边分别是内存空闲区域和内存使用区域,当对象创建要分配内存时,则移动指针,增大内存使用区域.
> 1.2.空间列表
>	当在内存区域创建对象时,将这个对象在内存中的地址值记录在一张表中,通过维护这张表从而进行对象内存的分配


**1.3.2.对象的结构**
> 1.对象头信息
	自身运行是数据
	包含:哈希值,GC分代年龄,锁的状态标识,线程持有的锁,偏向线程ID,偏向时间戳
	类型指针
> 2.对象数据
	对象存放的数据
> 3.对象补全
	一个对象占有的内存是8个Bit的整数倍,当一个对象不足8个Bit的整数倍时,便会使用这个区域补全数据
**1.3.3.对象的访问**
> 1.直接访问
	栈中的对象直接记录在堆中内存的地址值
> 2.句柄访问
	栈中的对象记录句柄池中指向的堆中内存的地址值,通过句柄池访问堆中的内存,则栈中变量记录的地址值则不需要发生改变.
## 1.4 垃圾回收
**1.垃圾判断算法**
> 1.引用计数法
	每一个对象都会记录自身被用于的计数,当这个计数为0时,则被回收
	但是,当栈内不引用这个对象时,这个对象在堆中被其他对象引用,这个对象等于是不发访问的
	但引用计数为1 ,垃圾回收不了
> 2.可达性分析法
	用过引用的路线的方式进行判断,当一些对象不能被GCRoots的对象所引用时,则会被垃圾回收
	GCRoots对象:
		1.虚拟机栈中的对象
		2.方法区的类属性所引用的对象
		3.方法区常量所引用的对象
		4.本地方法栈中引用的对象

**2.垃圾回收算法**
> 1.标记-清除算法
	对要进行GC的对象进行标记,然后清除,会产生大量不连续内存
> 2.复制算法
	将内存分为两个区域,在一个区中创建对象,当GC时,将存活的对象移动到另外的区域,然后将本区间的对象进行清除,会浪费一半的内存
> 3.标记-整理算法
	当GC时,在内存中指定一片区域进行GC,在这边区域中存活的对象往外移动,区域之外没有存活的对象往这边区域移动,
> 4.分代算法
	根据新生代和老年代的特性,选择不同的算法
> 5.堆中内存的划分
	1.新生代
		1.Eden
			占据新生代内存80%的区域,对象的创建便是在这个区域中进行,当在该区域中进行GC存活下来的对象会移动到Survivor区域中
		2.Survivor
			Survivor区域在新生代中有两个,当在Eden存活的对象移动到该区域中,该区域进行GC时,会将存活的对象移动到另外的Survivor区域中.
		3.Tenured Gen
			担保区,当Eden与Survivor内存不够时,该区域便会向老年代借用内存,用于存储对象
	2.老年代

**3.垃圾收集器**
> 1.serial
	最基本最悠久的垃圾回收器,单线程的
> 2.parnew
	在serial基础上的多线程的
> 3.parallel
	在parnew基础上,可以控制吞吐量(代码运行时间/(代码运行时间+垃圾回收停顿时间))
> 4.cms
	并发垃圾回收
	工作流程
        1.初始标记
        2.并发标记
        3.重新标记
        4.并发清除
	优点
		1.并发收集
		2.低停顿
	缺点
		1.占用大量CPU(多个线程并发执行)
		2.无法处理浮动垃圾(当在并发清除时,产生的垃圾)
		3.出现Concurrent Mode Failure(并发清除会划分出一片内存用于存放并发清除时创建的对象,当划分的内存不够时则会提示这个)
		4.空间碎片(使用标记清除算法)

> 5.g1
> 	没有新生代与老年代的概念,将总的内存区域分成一个一个小的内存单元,通过维护一张表,给整个内存进行评分并进行排序,将评分高的区域进行GC

## 1.5 内存分配
## 1.6 JVM工具
## 1.7 Class结构
## 1.8 字节码与指令
## 1.9 类的加载

# 2.多线程
# 3.数据库
# 4.算法