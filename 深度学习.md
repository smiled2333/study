# 1.jvm
##	1.1 Java虚拟机
>1.HotSpot sun公司默认使用的JVM
	1.不区分本地方法栈和虚拟机栈 

##	1.2 Java内存区域

![](.\image\java内存区域.png)

**1.线程独占区**
	1.1.堆
		所有创建的对象实例都会在堆中创建,开辟内存空间
	1.2.方法区
		存放类的类型信息(成员变量,成员方法,静态变量,静态方法,类的字节码信息)
	类的版本,字段,方法,接口等信息
**2.线程共享去**
	2.1.虚拟机栈
		用于执行Java方法,每一个方法进栈,都会创建一个栈针,当方法执行完成,则栈针出栈
	2.2.本地方法栈
		用于执行native方法, 
	2.3.程序计数器
		用于记录程序执行行数
**3.直接内存与运行时常量池**
	3.1.直接内存
		java程序会使用的总的内存
	3.2.运行时常量池
		运行时常量池是在方法区中,存放编译期间生成的自变量和符号应用的
## 1.3 对象
**1.3.1.对象的创建**
![](.\image\java对象的创建.png)

> 1.内存分配
> 1.1.指针碰撞
> 	将类创建的内存区域中增加一个指针,指针两边分别是内存空闲区域和内存使用区域,当对象创建要分配内存时,则移动指针,增大内存使用区域.
> 1.2.空间列表
>	当在内存区域创建对象时,将这个对象在内存中的地址值记录在一张表中,通过维护这张表从而进行对象内存的分配


**1.3.2.对象的结构**
> 1.对象头信息
	自身运行是数据
	包含:哈希值,GC分代年龄,锁的状态标识,线程持有的锁,偏向线程ID,偏向时间戳
	类型指针
> 2.对象数据
	对象存放的数据
> 3.对象补全
	一个对象占有的内存是8个Bit的整数倍,当一个对象不足8个Bit的整数倍时,便会使用这个区域补全数据
**1.3.3.对象的访问**
> 1.直接访问
	栈中的对象直接记录在堆中内存的地址值
> 2.句柄访问
	栈中的对象记录句柄池中指向的堆中内存的地址值,通过句柄池访问堆中的内存,则栈中变量记录的地址值则不需要发生改变.
## 1.4 垃圾回收
**1.垃圾判断算法**
> 1.引用计数法
	每一个对象都会记录自身被用于的计数,当这个计数为0时,则被回收
	但是,当栈内不引用这个对象时,这个对象在堆中被其他对象引用,这个对象等于是不发访问的
	但引用计数为1 ,垃圾回收不了
> 2.可达性分析法
	用过引用的路线的方式进行判断,当一些对象不能被GCRoots的对象所引用时,则会被垃圾回收
	GCRoots对象:
		1.虚拟机栈中的对象
		2.方法区的类属性所引用的对象
		3.方法区常量所引用的对象
		4.本地方法栈中引用的对象

**2.垃圾回收算法**
> 1.标记-清除算法
	对要进行GC的对象进行标记,然后清除,会产生大量不连续内存
> 2.复制算法
	将内存分为两个区域,在一个区中创建对象,当GC时,将存活的对象移动到另外的区域,然后将本区间的对象进行清除,会浪费一半的内存
> 3.标记-整理算法
	当GC时,在内存中指定一片区域进行GC,在这边区域中存活的对象往外移动,区域之外没有存活的对象往这边区域移动,
> 4.分代算法
	根据新生代和老年代的特性,选择不同的算法
> 5.堆中内存的划分
	1.新生代
		1.Eden
			占据新生代内存80%的区域,对象的创建便是在这个区域中进行,当在该区域中进行GC存活下来的对象会移动到Survivor区域中
		2.Survivor
			Survivor区域在新生代中有两个,当在Eden存活的对象移动到该区域中,该区域进行GC时,会将存活的对象移动到另外的Survivor区域中.
		3.Tenured Gen
			担保区,当Eden与Survivor内存不够时,该区域便会向老年代借用内存,用于存储对象
	2.老年代

**3.垃圾收集器**
> 1.serial
	最基本最悠久的垃圾回收器,单线程的
> 2.parnew
	在serial基础上的多线程的
> 3.parallel
	在parnew基础上,可以控制吞吐量(代码运行时间/(代码运行时间+垃圾回收停顿时间))
> 4.cms
	并发垃圾回收
	工作流程
        1.初始标记
        2.并发标记
        3.重新标记
        4.并发清除
	优点
		1.并发收集
		2.低停顿
	缺点
		1.占用大量CPU(多个线程并发执行)
		2.无法处理浮动垃圾(当在并发清除时,产生的垃圾)
		3.出现Concurrent Mode Failure(并发清除会划分出一片内存用于存放并发清除时创建的对象,当划分的内存不够时则会提示这个)
		4.空间碎片(使用标记清除算法)

> 5.g1
> 	没有新生代与老年代的概念,将总的内存区域分成一个一个小的内存单元,通过维护一张表,给整个内存进行评分并进行排序,将评分高的区域进行GC

## 1.5 内存分配

​	内存分配策略

​		1.优先分配到Eden

​		2.大对象直接分配到老年代

​		3.长期存活的对象分配到老年代

​		4.空间分配担保

​		5.动态对象年龄判断

新生代 采用复制算法

​	Eden区占80% SurvivorRatio占10%*2

​	GC

老年到

​	Full GC 

## 1.6 JVM工具

### 1.Jps

​	java 进程的状态,命令行工具

​	使用参数

```
jps :查询当前运行的java程序的进程号
jps -l :查询java程序运行的主类
jps -m :标识java程序运行时接收的参数
jps -v :查看jvm接收的参数
```

### 2.Jstat

​	在jps基础上用于监控指定java程序的命令行工具

​	主要可以监控类加载,内存,垃圾回收,jit编译信息

使用

```
jstat -gcutil java进程号 :查看gc信息
jstat -gcutil java进程号  秒  次 :查看gc信息,每个多少秒监控一次,共监控多少次
```

### 3.Jinfo

​	实时查看和调整jvm的各项参数

使用

```

```

### 4.Jmap

​	参考堆快照

使用

```
jmap -dump:format=b,file=路径 :生成堆快照信息
```

### 5.Jhat

​	可视化堆快照分析工具

### 6.Jstack

​	生成当前jvm内的线程快照

### 7.JConsole

​	界面监控工具箱

### 8.VisualVM 

​	第三方工具,与就console类似

​	https://visualvm.github.io/index.html

## 1.7 Class结构
## 1.8 字节码与指令
## 1.9 类的加载

## 1.10 JVM参数

## 1.11 性能调优



# 2.多线程

## 1.线程

**1.进程**    计算机上运行的程序叫做进程

**2.线程**   进程中的执行单元

**3.同步与异步**   同步方法一旦调用,就必须要等待方法执行完成才可以往下执行,异步方法调用后无需等待方法执行完成,便可以继续往下执行,

**4.并行与并发**  并发执行,是指一个处理器同时执行多个任务,但在一个时间点,只有一个任务会被执行,

​			 并行执行,是指多个处理器同时执行多个任务,并且在一个时间点上,可能有多个任务被执行

**5.java时间多线的方式**

​	1.继承Thread，重写run（）方法：并通过start(),方法启动线程

​	2.实现Runable接口,时间run()方法 ,在创建Thread对象将实现Runable接口的对象传入Thread对象中

**6.线程安全**  当多个线程访问某一个类（对象或方法）时，这个类始终能表现出正确的行为，那么这个类（对象或方法）就是线程安全的

**7.synchronized修饰符**

​	1.synchronized：可以在任意对象及方法上加锁，而加锁的这段代码称为**互斥区**或**临界区**。

**8.一个对象有一把锁！多个线程多个锁**

**9.线程的状态**

![enter image description here](https://images.gitbook.cn/4086a3a0-b4a1-11e8-8cec-e73b093e0df7)
**9.对象锁的同步和异步**   异步:没有共享的资源

## 2.锁

### 1.synchronized
1.可重入
    （1）关键字Synchronized拥有锁重入的功能，也就是在使用Synchronized的时候，当一个线程得到一个对象的锁后，在该锁里执行代码的时候可以再次请求该对象的锁时可以再次得到该对象的锁。
    （2）也就是说，当线程请求一个由其它线程持有的对象锁时，该线程会阻塞，而当线程请求由自己持有的对象锁时，如果该锁是重入锁，请求就会成功，否则阻塞。
    （3）一个简单的例子就是：在一个Synchronized修饰的方法或代码块的内部调用本类的其他Synchronized修饰的方法或代码块时，是永远可以得到锁的，示例代码A如下：
    (4)可重入锁可以避免死锁
    (5)可重入锁的原理
    http://www.cnblogs.com/pureEve/p/6421273.html
2.出现异常时，锁自动释放
3.将任意对象作为监视器monitor
### 2.volatile
	volatile 修饰一个变量，强制让使用这个变量的线程到主内存中获得对象
### 3.Lock
	ReentrantLock :Lock 接口的实现类
	    lock.lock();  加锁,
	    lock.unlock(); 释放锁
		ReentrantLock(boolean fair) :创建该锁释放为公平锁(true),
		getHoldCount()方法：查询当前线程保持此锁定的个数，也就是调用lock()的次数；
		getQueueLength()方法：返回正等待获取此锁定的线程估计数目；
		isFair()方法：判断是不是公平锁；
	Condition condition = lock.newCondition(); :监听器,可以创建多个
	    Condition.await() :执行该方法的线程进入等待状态
	    Condition.signal() :随机唤醒该监听器上的一个线程
	    Condition.signalAll() :唤醒该监听器上的全部线程
   ReentrantReadWriteLock :ReentrantLock对象的升级版,在ReentrantLock对象的基础上,提供
  读锁与写锁,
	（1）读读共享； 
    （2）写写互斥； 
    （3）读写互斥； 
    （4）写读互斥;
    	lock.readLock().lock(); 读锁加锁
    	lock.readLock().unlock();读锁释放锁
    	lock.writeLock().lock();写锁加锁
    	lock.writeLock().unlock();写锁释放锁
### 4.公平锁和非公平锁
	公平锁:线程获取锁的顺序是按照线程加锁的顺序来分配，即先进先出，那么他就是公平的
	非公平:是一种抢占机制，是随机获得锁，并不是先来的一定能先得到锁，结果就是不公平的
## 3.并发对象
### 1.ThreadLocal
	ThreadLocal 并发变量，可以存储线程私有的变量
### 2.ConcurrentHashMap
	1.原理
	2.使用
	3.并发
### 3.线程计数器
1.倒计时 CountDownLatch
	 new CountDownLatch(count); 创建时:指定计数
	 countDownLatch.countDown(); 计数
	 countDownLatch.await();     等待计数完成
	在创建对象指定计数,当一个线程执行countDown() 方法时,便会将计数减1,当计数为0时,便会唤醒在对象上等待的线程,当线程执行await()方法时便会进入等待状态,当计数为0时,便可以继续执行,在创建对象指定计数,便无法在更改计数
2.循环屏障 CyclicBarrier
	new CyclicBarrier(count, new Runnable())
	在创建对象时,指定计数与等待完成将会执行的方法,当线程执行await()方法时便会进入等待状态,并同时对计数减1,当计数为0 时,便会唤醒等待的线程,并执行创建对象时指定的Runnable中的run方法,
3.CyclicBarrier和CountDownLatch的区别
    （1）CountDownLatch的计数器只能使用一次。而CyclicBarrier的计数器可以使用reset() 方法重置。所以CyclicBarrier能处理更为复杂的业务场景，比如如果计算发生错误，可以重置计数器，并让线程们重新执行一次。
    （2）CyclicBarrier还提供其他有用的方法，比如getNumberWaiting方法可以获得CyclicBarrier阻塞的线程数量。isBroken方法用来知道阻塞的线程是否被中断。比如以下代码执行完之后会返回true。
    （3）CountDownLatch会阻塞主线程，CyclicBarrier不会阻塞主线程，只会阻塞子线程。




## 4.线程通信
	我们知道线程是操作系统中独立的个体，但是这个单独的个体之间没有一种特殊的处理方式使之成为一个整体，线程之间没有任何交流和沟通的话，他就是一个个单独的个体，不足以形成一个强大的交互性较强的整体。
	Java的一种实现线程间通信的机制是：wait/notify线程间通信
**wait方法：**
（1）方法wait()的作用是使当前执行代码的线程进行等待，该方法会将该线程放入”预执行队列“中，并且在wait()所在的代码处停止执行，直到接到通知或被中断为止。
（2）**在调用wait()之前，线程必须获得该对象级别锁**，这是一个很重要的地方，很多时候我们可能会忘记这一点，即只能在同步方法或同步块中调用wait()方法。
（3）还需要注意的是wait()是**释放锁**的，即在执行到wait()方法之后，当前线程会释放锁，当从wait()方法返回前，线程与其他线程竞争**重新获得锁**。
**notify方法：**
（1）和wait()方法一样，notify()方法也要在同步块或同步方法中调用，即在调用前，线程也必须获得该对象的对象级别锁。
（2）该方法是用来通知那些可能等待该对象的对象锁的其他线程，如果有多个线程等待，则由线程规划器随机挑选出其中一个呈wait状态的线程，对其发出通知notify，并使它等待获取该对象的对象锁。
（3）这里需要注意的是，执行notify方法之后，当前线程不会立即释放其拥有的该对象锁，而是执行完之后才会释放该对象锁，被通知的线程也不会立即获得对象锁，而是等待notify方法执行完之后，释放了该对象锁，才可以获得该对象锁。
（3）notifyAll()通知所有等待同一共享资源的全部线程从等待状态退出，进入可运行状态，重新竞争获得对象锁。
**wait()/notify()方法总结：**
（1）wait()/notify()要集合synchronized关键字一起使用，因为他们都需要首先获取该对象的对象锁；
（2）wait方法是释放锁，notify方法是不释放锁的；
（3）线程的四种状态如下图：
![enter image description here](https://images.gitbook.cn/93e71670-b0b3-11e8-bcb3-2f126f2e2442)
**其他注意事项**
（1）wait()和notify()方法要在同步块或同步方法中调用，即在调用前，线程也必须获得该对象的对象级别锁.
（2）wait方法是释放锁，notify方法是不释放锁的；
（3）notify每次唤醒wait等待状态的线程都是随机的，且每次只唤醒一个；
（4）notifAll每次唤醒wait等待状态的线程使之重新竞争获取对象锁，优先级最高的那个线程会最先执行；
（5）当线程处于wait()状态时，调用线程对象的interrupt()方法会出现InterruptedException异常；

##3.线程池

java对线程池的支持
Executors.newFixedThreadPool：该方法返回一个固定线程数量的线程池；
Executors.newSingleThreadExecutor：该方法返回一个只有一个现成的线程池；
Executors.newCachedThreadPool：返回一个可以根据实际情况调整线程数量的线程池；
Executors.newSingleThreadScheduledExecutor：该方法和newSingleThreadExecutor的区别是给定了时间执行某任务的功能，可以进行定时执行等；
Executors.newScheduledThreadPool：在4的基础上可以指定线程数量。
以上五种创建线程的方法,实际上都是在创建ThreadPoolExecutor对象,使用的都是默认的参数
	创建线程池,参数的含义
    1、corePoolSize 核心线程池大小；
    2、maximumPoolSize 线程池最大容量大小；
    3、keepAliveTime 线程池空闲时，线程存活的时间；
    4、TimeUnit 时间单位；
    5、ThreadFactory 线程工厂；
    6、BlockingQueue任务队列；
    7、RejectedExecutionHandler 线程拒绝策略；
线程池,提交任务:Future=submit(Runnable): 提交需要返回值的任务,无法捕捉异常,
			execute():			提交不需要返回值的任务,可以辅助异常
			future.get()||get（long timeout，TimeUnit unit）;
	 关闭线程池:shutdown()
# 3.数据库

# 4.算法